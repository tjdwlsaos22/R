240307_R
​
#GDP가 3000000이상인 국가만 빨간색으로 표시하기.

GDP_ranking15
GDP_ranking15$GDP
par(family="AppleGothic",bg='white')
GDP_ranking15$GDP <- as.numeric(str_replace_all(GDP_ranking15$GDP, ",", ""))
barplot(GDP_ranking15$GDP/1000,
ylim = c(0,25000),
main = "2018년 GDP 세계 15위 국가",
xlab ="국가(nation)",  #x축이름
ylab ="단위(달러)",  #y축이름
col = ifelse(GDP_ranking15$GDP/1000 >= 3000,'red','blue') , 그냥 3000000으로도 써도되지만 위에 1000단위로 나눴기때문에 이래도됨
names = GDP_ranking15$Code)​
​
dplyr 설치 필요
#Sepal.Length 기준으로 오름차순 정렬
head(arrange(iris, Sepal.Length))​
​
#Sepal.Length 기준으로 오름차순 정렬후 1열과 2열만 보기
head(arrange(iris[,1:2],Sepal.Length)) # 1열과 2열에는 Petal이 없기때문에 만약 Sepal이 아닌 Petal일경우에는 오류가 난다.
#Sepal.Length 기준으로 정렬후 동일한 크기를 가진 데이터 발생시 Petal.Length 기준으로 오름차순 정렬
arrange(iris, Sepal.Length, Petal.Length)​
​
#Sepal.Length 기준으로 내림차순 정렬
arrange(iris,desc(Sepal.Length))​
​
#Sampling(중복값을 허용하지 않음) - 집합.
iris$Sepal.Length
sample(iris$Sepal.Length,30)​
​
sample(1:nrow(iris),nrow(iris)*0.7)​
​
samp <- sample(1:nrow(iris),nrow(iris)*0.7)
irisTrain <- iris[samp,]
head(irisTrain) -- 테이블형태로 나옴.
​
samp <- c(sample(1:50,35),sample(51:100,35),sample(101:150,35))
irisTrain <- iris[samp,]
head(irisTrain)
table(irisTrain$Species)​
이렇게 해줘야 table이 잘나온다.
​
set.seed(1234) #랜덤샘플링의 알고리즘 정의
samp <- c(sample(1:50,35),sample(51:100,35),sample(101:150,35))
irisTrain <- iris[samp,]  ## 다른사람이랑 값이 똑같이나옴.
irisTest <-iris[-samp,]
summary(irisTest)
summary(irisTrain)
head(irisTrain)
head(irisTest)
summary(iris). summary비교해서 비슷하면 되는거임.
​
#모집단에서 필요한 데이터만 추출하기
#iris에서 species가 Setosa인것만 추출해서 iris_Setosa라는 데이터 프레임 만들기

iris_setosa <- subset(iris,Species == 'setosa'). subset이 추출하는 명령어. 이름,바꿀열이름 =='추출할 값'
iris_setosa
str(iris_setosa) ## factor가 1개가 아닌 3개가 나오는것이라 바꿔줘야함. setosa만 나와야함. 이거 바형태해도 3개가 나오게 되는 현상나옴
#만약 여기서 봤을때 앞에 rownames가 1부터 시작이 아니라면 1부터 시작해주기 위해서
​
rownames(변수이름) <- c() 사용해서 1부터로 바꿔주고 팩터 바꿔줘야한다.

iris_versicolor <- subset(iris,Species == 'versicolor') 조건추가시에 & 붙이고 다음거 쓰면됨 iris는 쓸필요없이 조건만 적으면됨.
iris_versicolor
str(iris_versicolor) ## factor가 1개가 아닌 3개가 나오는것이라 바꿔줘야함. setosa만 나와야함. 이거 바형태해도 3개가 나오게 되는 현상나옴

#factor 조정
rownames(iris_versicolor) <-c()
head(iris_versicolor)

iris_versicolor$Species <- factor(iris_versicolor$Species)  # 이렇게 설정해주면 위에 설정한 값만 나오게됨.
str(iris_versicolor)


​
​
#factor 조정
iris_setosa$Species <- factor(iris_setosa$Species)  # 이렇게 설정해주면 위에 설정한 값만 나오게됨.
str(iris_setosa)​
​
subset(iris,select = -Species). 열 지우기!
​
mean(iris$Sepal.Width[iris$Species == 'setosa'])​
iris$Sepal.Width 의 평균을 구하는데 iris$Species가 setosa인 것.​
​
mean(iris$Sepal.Width[iris$Species == 'setosa'])
mean(iris$Sepal.Width[iris$Species == 'versicolor'])
mean(iris$Sepal.Width[iris$Species == 'virginica'])

mean(subset(iris, Species == 'setosa')$Sepal.Width)

aggregate(Sepal.Width~Species,iris,mean) aggregate 사용해서 통합할수 있음. ~뒤는 조건, iris는 데이터위치,mean은 평균구하기위함.
​
sum(is.na(seoul))
#column별 na확인
for(i in 1:ncol(seoul)){
    cat("컬럼명 :",colnames(seoul[i]),"\t",sum(is.na(seoul[,i])),"\n")
    
}​
​
colSums(is.na(seoul)) ---- 이게 더 쉬움!
​
length(unique(seoul$`자치구명`)) --ncol쓰는게 아님(이건 총 열의갯수일뿐) 이건 자치구명의 총갯수인데 이걸 unique주고 중복없애면갯수
​
table(seoul$`년도`)
for(i in 1:3){
    print(table(seoul[,i])). 빈도수 확인
}​
​
aggregate(발생건수~자치구명,seoul,mean). 문자열도 '없이 그냥 적는다. 발생건수의평균(자치구 별로)
평균,그룹(별),데이터,함수
​
arrange(aggregate(발생건수~자치구명,seoul,mean),desc(발생건수)) 이렇게 해서 평균구한것에 대해 발생건수를 내림차순 정렬이 가능하다.

seoul
a <- aggregate(발생건수~자치구명,seoul,mean)
head(arrange(aggregate(발생건수~자치구명,seoul,mean),desc(발생건수)))
region.sd <- aggregate(발생건수~자치구명,seoul,sd)
head(region.sd)
#ㅈ치구별의 발생건수의 변동계수
#변동계수 = 편차/평균
gyusu <- region.sd$`발생건수`/a$`발생건수`
head(gyusu)
# 변동계수를 가진 dataframe만들기
regionADD <- data.frame(자치구명=a$`자치구명`,변동계수=gyusu)
head(regionADD)

arrange(regionADD,변동계수)

#서울시 교통사고 부상자수에 대한 변동계수 구하기

#평균
regionInjure.mean <- aggregate(부상자수~자치구명,seoul,mean)

#
regionInjure.sd <-aggregate(부상자수~자치구명,seoul,sd)

#
regionInjure.cv <- round(regionInjure.sd[,2]/regionInjure.mean[,2],3)

#
regionInjure <- data.frame(자치구명=regionInjure.mean$`자치구명`,변동계수=regionInjure.cv)

regionInjure <- arrange(regionInjure,desc(변동계수))
head(regionInjure)

#교통사고 발생건수와 부상자수의 관계 : 상관관계 - 강한관계
abs(round(cor(seoul$`발생건수`,seoul$`부상자수`),3))

#교통사고 발생건수와 사망자수의 관계 : 상관없음
abs(round(cor(seoul$`발생건수`,seoul$`사망자수`),3))

#교통사고 부상자수와 사망자수의 관계 : 상관없음
abs(round(cor(seoul$`부상자수`,seoul$`사망자수`),3)). 절댓값으로 해줘야한다(-인경우도있다. abs)

#0~0.3 : 상관없음
#0.3~0.5: 약한 관계
#0.5~0.7: 관계
#0.7~ : 강한관계​
​
par(family = "AppleGothic",bg='white')
#발생건수와 부상자수의 산포도 그리기
plot(seoul$`발생건수`,
    seoul$`부상자수`) # 제일 분석하기 쉬운 산포도
barplot(seoul$`발생건수`,
    seoul$`사망자수`)
plot(seoul$`발생건수`,
    seoul$`사망자수`)   ##정규분포다​
​
​
x <-1:10
y<-1:10
par(family = "AppleGothic",bg='white')
plot(x,y)
plot(y~x)
par(family = "AppleGothic",bg='lightgray')
#발생건수와 부상자수의 산포도 그리기
seoul <- read.csv("./Data/newSeoul2019.csv",stringsAsFactors = T)
plot(seoul$`발생건수`,
    seoul$`부상자수`,
    col = ifelse(seoul$발생건수> 150,'blue','red'),
    main = "서울시 교통사고 발생건수와 부상자수 산포도",
    xlab ="발생건수",  #x축이름,
    ylab ="부상자수"  #y축이름 
    
    
    
    ) # 제일 분석하기 쉬운 산포도​
​
​
x <-1:10
y<-1:10
par(family = "AppleGothic",bg='white')
plot(x,y,
    xlim=c(11,0), #x축의 범위설정
    ylim=c(0,11)

)​
​
ganggwang <- subset(seoul,자치구명 == '강남구' | 자치구명 == '광진구')
rownames(gangnam) <- c()
par(family = "AppleGothic",bg='lightgray')
plot(ganggwang$`발생건수`,
    ganggwang$`부상자수`,
    col = ifelse(ganggwang$`자치구명`=='강남구','red','blue'),
    main = "강남구,광진구 교통사고 발생건수와 부상자수 산포도",
    xlab ="발생건수",  #x축이름,
    ylab ="부상자수"  #y축이름 
    
    
    
    ) # 제일 분석하기 쉬운 산포도​
이걸 굳이 하나하나 나누기말고 하나에 광진구나 강남구인걸 뽑아서 값이 강남구면 파란색 아니면 빨간색으로 하는것이다.
​
par(family = "AppleGothic",bg='lightgray')
y <- c(1,3,2,4,8,5,7,6,9)
plot(y,
xlim = c(min(y)-1,max(y)+1),
ylim = c(min(y)-1,max(y)+1),
main="simple Time Series",
type='l')​
꺽은선 그래프. p는 포인터만, l은 라인까지 그려진다.
type='c' 는 수치, o는 오버랩. h는 크기
​
lty = 1~6까지.​
​
x <- runif(100)
y <- runif(100)

#0.5기준으로 0.5보다 크면 pch=1,아니면 pch=18
#0.5기준으로 0.5보다 크면 red,아니면 blue
par(family = "AppleGothic",bg='lightgray')
#plotting symbol
plot(x,y,
col = ifelse(x >0.5 | y>0.5, 'blue','greenyellow'),
pch=ifelse(x >0.5 | y>0.5, 1,18)
) #계단​
​
pch는 점을 원하는 문자로 변경가능.
​
par(family = 'AppleGothic',bg='lightgray')
plot(abc,
    type='o',
    col='red',
    axes=F, #x,y 좌표축 제거
    ann = F,
    ylim = c(0,400)) # x,y의 라벨 제거

    axis(1,at=1:5,lab = c('서울','대전','대구','광주','원주'))
    axis(2,ylim = c(0,400))

    title(main = '과일판매량',col.main='greenyellow',cex.main=3)

    #x축 라벨 지정
    title(xlab='지역',col.lab='blue',cex.main=2)
    title(ylab='판매량',col.lab='blue',cex.main=2)

    lines(def,
    type='o',
    pch=22,
    col='darkgreen',
    lty=2)

    lines(ghi,
    type='o',
    pch=29,
    col='blue',
    lty=6
    )

    legend(4,400,
        c('야구장','축구장','해변가'),
        col=c('red','blue','green'),
        lty=c(1,2,2),
        pch=c(21,29,22),
        cex = 0.8)
        #fill =c('red','blue','green')


        x <- 1:6
        names(x) <- c('A','B','C','D','E','F')
        barplot(x,
        main="1~6",
        xlab="sales",
        ylab="Amounts",
        col=c('red',rep('blue',5)))​
​
여러개의 꺽은선 그래프를 한 화면에 표시
​
#matrix
x <- matrix(1:6,3,2)
rownames(x) <- c('A','B','C')
x​
​
par(family='AppleGothic',bg='lightgray')
rownames(x) <- c('A','B','C')
barplot(x,
beside=T,   이거 F하면 겹쳐짐
main="수출량",
xlab='국가',
ylab='빈도수',
names = c('Korea','Usa'), #이거 이름 6개해도 들어가짐.
col = c('red','green','blue','black','white','yellow'),
legend.text = T,
ylim = c(0,8)

)​


​